"""
Portfolio management endpoints with database persistence
Updated to use SQLAlchemy instead of in-memory storage
"""

from typing import List, Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
import logging

# Import database and models
from core.database import get_db
from models.portfolio import (
    PortfolioPosition, PositionCreate, PositionUpdate, PositionResponse,
    PortfolioSummary, PortfolioResponse,
    get_user_portfolio, get_position_by_id, get_position_by_symbol,
    create_position, update_position, delete_position,
    calculate_portfolio_summary, convert_position_to_response,
    save_user_portfolio, create_sample_portfolio, get_portfolio_symbols,
    update_position_prices
)
from models.user import User


# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/api/v1/portfolios", tags=["portfolios"])

# ================================
# PORTFOLIO ENDPOINTS
# ================================

@router.get("/me", response_model=PortfolioResponse)
async def get_my_portfolio(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get current user's complete portfolio"""
    try:
        # Get portfolio positions
        positions = get_user_portfolio(db, current_user.id)
        position_responses = [convert_position_to_response(pos) for pos in positions]
        
        # Calculate summary
        summary = calculate_portfolio_summary(db, current_user.id)
        
        logger.info(f"Retrieved portfolio for user {current_user.email}: {len(positions)} positions")
        
        return PortfolioResponse(
            user_id=current_user.id,
            positions=position_responses,
            summary=summary,
            last_updated=max([pos.updated_at or pos.created_at for pos in positions], default=None)
        )
        
    except Exception as e:
        logger.error(f"Error retrieving portfolio for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve portfolio"
        )

@router.get("/positions", response_model=List[PositionResponse])
async def get_portfolio_positions(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get all positions in user's portfolio"""
    try:
        positions = get_user_portfolio(db, current_user.id)
        return [convert_position_to_response(pos) for pos in positions]
        
    except Exception as e:
        logger.error(f"Error retrieving positions for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve positions"
        )

@router.get("/summary", response_model=PortfolioSummary)
async def get_portfolio_summary(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get portfolio summary with aggregated statistics"""
    try:
        summary = calculate_portfolio_summary(db, current_user.id)
        logger.info(f"Portfolio summary for user {current_user.email}: {summary.total_positions} positions, ${summary.total_market_value:,.2f} value")
        return summary
        
    except Exception as e:
        logger.error(f"Error calculating portfolio summary for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to calculate portfolio summary"
        )

# ================================
# POSITION MANAGEMENT ENDPOINTS
# ================================

@router.post("/positions", response_model=PositionResponse)
async def add_position(
    position_data: PositionCreate,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Add new position to portfolio"""
    try:
        # Check if position already exists
        existing_position = get_position_by_symbol(db, position_data.symbol, current_user.id)
        if existing_position:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Position for {position_data.symbol} already exists. Use PUT to update."
            )
        
        # Create new position
        new_position = create_position(db, position_data, current_user.id)
        
        logger.info(f"Added position for user {current_user.email}: {position_data.symbol}")
        return convert_position_to_response(new_position)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error adding position for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to add position"
        )

@router.get("/positions/{position_id}", response_model=PositionResponse)
async def get_position(
    position_id: str,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get specific position by ID"""
    try:
        position = get_position_by_id(db, position_id, current_user.id)
        if not position:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Position not found"
            )
        
        return convert_position_to_response(position)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving position {position_id} for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve position"
        )

@router.put("/positions/{position_id}", response_model=PositionResponse)
async def update_position_endpoint(
    position_id: str,
    update_data: PositionUpdate,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Update existing position"""
    try:
        updated_position = update_position(db, position_id, current_user.id, update_data)
        if not updated_position:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Position not found"
            )
        
        logger.info(f"Updated position {position_id} for user {current_user.email}")
        return convert_position_to_response(updated_position)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating position {position_id} for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update position"
        )

@router.delete("/positions/{position_id}")
async def delete_position_endpoint(
    position_id: str,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Delete position from portfolio"""
    try:
        success = delete_position(db, position_id, current_user.id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Position not found"
            )
        
        logger.info(f"Deleted position {position_id} for user {current_user.email}")
        return {"message": "Position deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting position {position_id} for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete position"
        )

# ================================
# BULK OPERATIONS
# ================================

@router.post("/bulk-save", response_model=List[PositionResponse])
async def save_portfolio_bulk(
    portfolio_data: List[Dict[str, Any]],
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Save entire portfolio (replaces existing positions)"""
    try:
        # Use legacy function for bulk save
        positions = save_user_portfolio(db, current_user.id, portfolio_data)
        
        logger.info(f"Bulk saved portfolio for user {current_user.email}: {len(positions)} positions")
        return [convert_position_to_response(pos) for pos in positions]
        
    except Exception as e:
        logger.error(f"Error bulk saving portfolio for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save portfolio"
        )

@router.post("/update-prices")
async def update_portfolio_prices(
    price_updates: Dict[str, float],
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Update current prices for portfolio positions"""
    try:
        # Get user's portfolio symbols to validate updates
        user_symbols = get_portfolio_symbols(db, current_user.id)
        
        # Filter price updates to only include user's symbols
        filtered_updates = {
            symbol: price for symbol, price in price_updates.items() 
            if symbol.upper() in user_symbols
        }
        
        if not filtered_updates:
            return {"message": "No matching positions found for price updates", "updated_count": 0}
        
        # Update prices
        updated_count = update_position_prices(db, filtered_updates)
        
        logger.info(f"Updated prices for user {current_user.email}: {updated_count} positions")
        return {
            "message": f"Updated prices for {updated_count} positions",
            "updated_count": updated_count,
            "symbols_updated": list(filtered_updates.keys())
        }
        
    except Exception as e:
        logger.error(f"Error updating prices for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update prices"
        )

# ================================
# PORTFOLIO ANALYSIS ENDPOINTS
# ================================

@router.get("/allocation/sector")
async def get_sector_allocation(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get portfolio allocation by sector"""
    try:
        summary = calculate_portfolio_summary(db, current_user.id)
        return {
            "sector_allocation": summary.sector_allocation,
            "total_market_value": summary.total_market_value
        }
        
    except Exception as e:
        logger.error(f"Error calculating sector allocation for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to calculate sector allocation"
        )

@router.get("/allocation/asset-class")
async def get_asset_class_allocation(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get portfolio allocation by asset class"""
    try:
        summary = calculate_portfolio_summary(db, current_user.id)
        return {
            "asset_class_allocation": summary.asset_class_allocation,
            "total_market_value": summary.total_market_value
        }
        
    except Exception as e:
        logger.error(f"Error calculating asset class allocation for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to calculate asset class allocation"
        )

@router.get("/performance")
async def get_portfolio_performance(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Get portfolio performance metrics"""
    try:
        summary = calculate_portfolio_summary(db, current_user.id)
        positions = get_user_portfolio(db, current_user.id)
        
        # Calculate additional performance metrics
        best_performer = None
        worst_performer = None
        
        if positions:
            # Find best and worst performing positions
            position_responses = [convert_position_to_response(pos) for pos in positions]
            position_responses = [pos for pos in position_responses if pos.unrealized_gain_loss_percent is not None]
            
            if position_responses:
                best_performer = max(position_responses, key=lambda x: x.unrealized_gain_loss_percent or 0)
                worst_performer = min(position_responses, key=lambda x: x.unrealized_gain_loss_percent or 0)
        
        return {
            "total_return": summary.total_unrealized_gain_loss,
            "total_return_percent": summary.total_unrealized_gain_loss_percent,
            "total_market_value": summary.total_market_value,
            "total_cost_basis": summary.total_cost_basis,
            "position_count": summary.total_positions,
            "best_performer": {
                "symbol": best_performer.symbol,
                "return_percent": best_performer.unrealized_gain_loss_percent,
                "return_amount": best_performer.unrealized_gain_loss
            } if best_performer else None,
            "worst_performer": {
                "symbol": worst_performer.symbol,
                "return_percent": worst_performer.unrealized_gain_loss_percent,
                "return_amount": worst_performer.unrealized_gain_loss
            } if worst_performer else None
        }
        
    except Exception as e:
        logger.error(f"Error calculating portfolio performance for user {current_user.id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to calculate portfolio performance"
        )

# ================================
# DEVELOPMENT/TESTING ENDPOINTS
# ================================

@router.post("/debug/create-sample")
async def create_sample_portfolio_endpoint(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Create sample portfolio for testing"""
    try:
        # Check if user already has positions
        existing_positions = get_user_portfolio(db, current_user.id)
        if existing_positions:
            return {
                "message": "User already has portfolio positions",
                "existing_positions": len(existing_positions)
            }
        
        # Create sample portfolio
        sample_positions = create_sample_portfolio(db, current_user.id)
        
        logger.info(f"Created sample portfolio for user {current_user.email}: {len(sample_positions)} positions")
        return {
            "message": "Sample portfolio created successfully",
            "positions": [convert_position_to_response(pos) for pos in sample_positions]
        }
        
    except Exception as e:
        logger.error(f"Error creating sample portfolio for user {current_user.id}: {e}")
        return {"error": str(e)}

@router.get("/debug/info")
async def debug_portfolio_info(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Debug endpoint for portfolio information"""
    try:
        positions = get_user_portfolio(db, current_user.id)
        symbols = get_portfolio_symbols(db, current_user.id)
        
        return {
            "user_id": current_user.id,
            "user_email": current_user.email,
            "position_count": len(positions),
            "symbols": symbols,
            "positions_detail": [
                {
                    "id": pos.id,
                    "symbol": pos.symbol,
                    "quantity": float(pos.quantity),
                    "is_active": pos.is_active,
                    "created_at": pos.created_at.isoformat() if pos.created_at else None
                }
                for pos in positions
            ]
        }
        
    except Exception as e:
        logger.error(f"Portfolio debug error for user {current_user.id}: {e}")
        return {"error": str(e)}

# ================================
# LEGACY COMPATIBILITY ENDPOINTS
# ================================

@router.get("/", response_model=List[PositionResponse])
async def get_portfolio_legacy(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Legacy endpoint for backward compatibility"""
    return await get_portfolio_positions(current_user, db)

@router.post("/", response_model=List[PositionResponse])
async def save_portfolio_legacy(
    portfolio_data: List[Dict[str, Any]],
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """Legacy endpoint for backward compatibility"""
    return await save_portfolio_bulk(portfolio_data, current_user, db)

# ================================
# HEALTH CHECK ENDPOINT
# ================================

@router.get("/health")
async def portfolio_health_check(db: Session = Depends(get_db)):
    """Health check for portfolio system"""
    try:
        # Test database connection
        position_count = db.query(PortfolioPosition).count()
        
        return {
            "status": "healthy",
            "database_connection": "connected",
            "total_positions": position_count,
            "features": {
                "position_management": "operational",
                "portfolio_analysis": "operational",
                "price_updates": "operational"
            }
        }
    except Exception as e:
        logger.error(f"Portfolio health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }